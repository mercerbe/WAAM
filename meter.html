<!DOCTYPE html>
<html>
  <head>

   <style type="text/css">

    canvas {
      background: #000;
fill :#000;
border-radius: 7px;    }
@font-face{
  font-family: 'digi';
  src: url('fonts/digital-7_mono-webfont.eot');
  src: url('fonts/digital-7_mono-webfont.eot?#iefix') format('embedded-opentype'),
       url('fonts/digital-7_mono-webfont.woff') format('woff'),
       url('fonts/digital-7_mono-webfont.ttf') format('truetype'),
       url('fonts/digital-7_mono-webfont.svg#webfont') format('svg');
}
body {background: #000}
#mins,#secs,#milli {
    float: left;
    margin: 4px;
    font-size: 28px;
    color: #fff;
    font-family: 'digi';
    font-size: 50px;
}
#mins:after,#secs:after {
 content: ":"
}
}

    </style>

  </head>
  <body>

<div style="float: left; width: 250px;border: 1px solid #ccc;">
<div id="mins">00</div>
<div id="secs">00</div>
<div id="milli">00</div>
</div>

<div style="float: left; width: 200px;border: 1px solid #ccc;">
 <button id="play">Play</button>
 <button id="pause">Pause</button>
 <button id="start">Rewind</button>
</div>
<div style="float: left; width: 200px;border: 1px solid #ccc;">
<canvas id="myCanvas" width="130" height="400">
Your browser does not support the HTML5 canvas tag.
</canvas>
</div>
  <script>
(function() {
var startTime = +new Date();
var mi = document.getElementById('mins');
var secs = document.getElementById('secs');
var milli = document.getElementById('milli');
var currMins = 0;
var currSecs = 0;
function watchStart() {
setInterval(function() {
 var elapsed = new Date() - startTime;
    var curr = new Date(elapsed);
    var tenths = (curr.getMilliseconds() / 10) % 100;

    currSecs = curr.getSeconds();
    currMins = curr.getMinutes();

    if(curr.getSeconds() < 10) {
          currSecs = "0" + curr.getSeconds();

    }

    if(curr.getMinutes() < 10) {
          currMins = "0" + curr.getMinutes();

    }



    mi.innerHTML = currMins;
    secs.innerHTML= currSecs;
    milli.innerHTML= tenths.toFixed();
},10);
}

function getBuffer(context,fn) {
var request = new XMLHttpRequest();
    request.open('GET', 'audio/Vox.mp3', true);
    //xhr2 -
    request.responseType = 'arraybuffer';
    request.onload = function() {
      // Asynchronously decode the audio file data in request.response
      context.decodeAudioData(request.response,function(buff){
        buffer = buff;
        fn(buffer);
      },function(error) {
        console.log(error);
      });
  };
  request.send();

};
function audioCtx() {
  var audioCtx = (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext);
  if(audioCtx) {
        return new audioCtx();
  } else {
      alert('Web Audio API not supported in this browser. Please use a modern browser such as Chrome or Firefox');
      return;
  }
};
function Daw() {
  var self =  this;
    this.ctx = audioCtx();
    this.gain  = this.ctx.createGain();
    this.sources = [];
    this.loadSources();
    this.transport = new Transport(this.ctx,this);
    this.analyserLeft = this.ctx.createAnalyser();
        this.analyserLeft.smoothingTimeConstant = 0.3;
        this.analyserLeft.fftSize = 1024;
        this.analyserRight = this.ctx.createAnalyser();
        this.analyserRight.smoothingTimeConstant = 0.3;
        this.analyserRight.fftSize = 1024;
        this.javascriptNode = this.ctx.createScriptProcessor(2048, 1, 1);
        this.javascriptNode.connect(this.ctx.destination);
        this.splitter = this.ctx.createChannelSplitter();

        this.canvas = document.getElementById("myCanvas");
this.ctx = this.canvas.getContext("2d");
var on = true;
        this.javascriptNode.onaudioprocess = function() {

        if(on) {
        self.ctx.clearRect(0, 0, 400, 400);
        on = false;
      } else {
        on  = true;
      }


        // get the average, bincount is fftsize / 2
        var arrayLeft =  new Uint8Array(self.analyserLeft.frequencyBinCount);
        self.analyserLeft.getByteFrequencyData(arrayLeft);
        var averageLeft = getAverageVolume(arrayLeft);
         var arrayRight =  new Uint8Array(self.analyserRight.frequencyBinCount);
        self.analyserRight.getByteFrequencyData(arrayRight);
        var averageRight = getAverageVolume(arrayRight);
        var grd=self.ctx.createLinearGradient(0,0,0,250);
grd.addColorStop(0,"red");
grd.addColorStop(0.2,"orange");
grd.addColorStop(1,"green");
        self.ctx.fillStyle = grd;
        var top = 400 - (averageLeft * 4);
        topRight = 400 - (averageRight * 4);

self.ctx.fillRect(70,top,50,400);
self.ctx.fillRect(10,topRight,50,400 );
}
};
function getAverageVolume(array) {
        var values = 0;
        var average;

        var length = array.length;

        for (var i = 0; i < length; i++) {
            values += array[i];
        }

        average = values / length;
        return average;
    };
Daw.prototype.loadSources = function() {

}
function Transport(ctx,daw) {
  var start = offset = elapsed = 0,
      play = document.getElementById('play'),
      pause = document.getElementById('pause'),
      source,
      playing,
      buffer,
      duration;

  buffer = getBuffer(ctx,function(buffer) {
    duration = buffer.duration * 1000,

    play.addEventListener('click', function() {
        source = ctx.createBufferSource();
        currMin = currSecs = 0;
        watchStart();

console.log('wewe');
        source.buffer = buffer;


// connect the source to the analyser and the splitter
        source.connect(daw.splitter)
        daw.splitter.connect(daw.analyserLeft,0,0);
        daw.splitter.connect(daw.analyserRight,1,0);
        daw.analyserLeft.connect(daw.javascriptNode)
        source.connect(ctx.destination);

        source.start(0);

    });

  });
};
function init() {
    new Daw();
};
window.addEventListener('load', init, false);
})();
  </script>
  </body>
</html>
